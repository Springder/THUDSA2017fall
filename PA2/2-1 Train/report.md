1. 所使用数据结构与算法的构思、原理和实现要点。
  主要使用了栈，继承自list
2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
  题目本质上是栈混洗，关键看S什么时候pop：如果S为空或者需要的列车不是S的头，S才不会pop，应该看A：如果A为空或者不是A的头而且S满了，那么无法操作；如果是A的头就pass，如果不是A的头就将A的头弹出，然后压入S（即In），并且继续寻找该列车。如果需要的是S的头，则S会pop（即out）。本题也就是在一般的栈混洗过程中对S的size需要加以判别，最快的算法还是模拟整个过程，难度不大。
  不过最坑的就是如果不能混洗，需要输出"No"，而我一开始输出的是"NO"，结果debug了好几个小时...

3. 时间和空间复杂度的估算。

  空间复杂度：O(n)，每一辆列车至多为两步（In, out），至少为一步（pass），都是O(1)时间。总体复杂度即为O(n)。
  空间复杂度：O(n)，用了A栈、S栈、储存操作过程的栈。
4. （可选）介绍理论分析与实测效果的吻合程度，不吻合时进一步解释原因。
5. （可选）所用方法的特别、新颖或创新之处。