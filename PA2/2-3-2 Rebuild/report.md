1. 所使用数据结构与算法的构思、原理和实现要点。
	主要使用了二叉树
2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
	课堂上邓老师讲过关于先序或后序加中序，而先序加后序并不复杂。先序的第一个即为根节点，左一为左孩子。后序的右一为右孩子。然后在后序中找到左孩子，对应的那个点之前的一段为左子树。先序中左孩子后面相同长度的一段也为左子树。那么右子树就是剩下的了（除了根节点）。那么问题被减而治之为左子树和右子树的重构，递归算法非常简单。但是这种递归其实也可以用辅助栈帮助完成：每次先重构左子树，右子树入栈。完成过程中，我用了数组储存先序和后序的输出，并没有用list。因为在处理过程中，数的顺序是有意义的，而且要批量传递。用数组的话我只要传递数组某一段的起点和终点。树重构完了用中序遍历算法输出即可。
3. 时间和空间复杂度的估算。
	时间复杂度：O(n)。每个节点需要O(1)的时间构建。
	空间复杂度：O(n)，需要完整地存储两个数组+一棵树。
总的来说本程序效率还算可以，恰好排在top的最后一位（id为在下泽民，有何贵干）
4. （可选）介绍理论分析与实测效果的吻合程度，不吻合时进一步解释原因。
5. （可选）所用方法的特别、新颖或创新之处。