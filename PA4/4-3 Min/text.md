# THU2017 4-3 Min

------

### **描述**

　　目前我们已经进入了大数据（Big Data）时代，所需要处理的数据规模越来越大，不幸的是，领导交给你的机器仍然是一台老旧的电脑，其内存之低令人发指。不过领导要求你完成的任务却很严苛：希望能在海量的数据中，选出他希望的值。

　　具体来说，他给了你一块装有大量数据的磁盘，每个数据只包括一个int类型（有符号32bit整数），现在他希望你从中选出第k**小**的数字，这本来是一个简单的任务，不过考虑到受限的内存，简单的任务也变得复杂起来。

### **输入**

　　为了加快输入输出速度，输入文件采用二进制格式存储。前两个数字n和k，表示你需要从n个数字中选出第k小的数字。之后随即连续存储了n个整数。

### **输出**

　　输出第 k **小**的数字。

### **输入样例**

```
6
3
1
4
-5
1
4
-2
```

　　特别注意：实际输入均为二进制文件，所有数据连续存储，并没有行的概念。

### **输出样例**

```
1
```

### **限制**

　　1 <= n <= 3,000,000

　　1 <= k <= 50,000

　　k <= n

　　输入的数字均为有符号32位整数。

　　你只有非常有限的空间来完成任务。

　　时间：1 sec

　　空间：13MB

　　*即使提交一个只包含空的main函数的程序，也会占用一定空间，这部分空间已经考虑在内。

　　*这题的编译流程做了特殊设置，提交.c文件也会占用跟.cpp相同的运行空间。

### **提示**

　　自己测试时，如果对读入二进制数据不熟悉，可以以文本的形式读取数据；提交到OJ时，参考如下代码修改读取数据的方式：

```
int n, k;
fread(&n, sizeof(int), 1, stdin);
fread(&k, sizeof(int), 1, stdin);
int *data = new int[n];   // 此处仅为示意，若直接开这么大的数组会超过内存限制
fread(data, sizeof(int), n, stdin);
```

　　输出请不要使用二进制方式输出，直接以人可读的方式输出结果即可。

- 抛弃多余的数据，仅仅维护输出所需的元素即可。使用优先级队列，可以实现快速的存取。注意根据内存限制设计合适的读入数据方案。