1. 所使用数据结构与算法的构思、原理和实现要点。
  优先级队列，基于数组实现。

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
  此问题很简单，只要维护一个大小为$k$的大顶堆即可：首先将前$k$个数批量建堆（我用的是依次插入的算法）。然后对于剩余的数，与堆顶（max）比较，如果小于max，说明该数应该是在“最小的k个数”里面，而堆顶正好被其取代：摘掉堆顶，插入该数（使用默认插入算法，即接到向量末尾然后上滤）。如此下去，最后堆顶一定是从小到大第$k$个数。

3. 时间和空间复杂度的估算。

   $k$个数依次插入：总的复杂度至多为$\sum_{i=1}^k{O(\log i)}$，总复杂度为$O(k\log k)$。剩余$n-k$个数里面，考虑$k<<n$，每次插入复杂度也是$O(\log n)$。综上，总体时间复杂度为$O(n\log n)$。空间复杂度为$O(k)$，因为只要维持$k$个数的大顶堆（不考虑读入的数据存入的数组的话）。

4. （可选）介绍理论分析与实测效果的吻合程度，不吻合时进一步解释原因。

5. （可选）所用方法的特别、新颖或创新之处。