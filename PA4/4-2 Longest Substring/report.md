1. 所使用数据结构与算法的构思、原理和实现要点。
  hashtable，基于dictionary和bitmap

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。

  * hash function. 用到了多项式hash function和快速幂取模算法。
  * 找出长度为len的字符串的出现次数。对于n-len个长度为len的子字符串，依次计算hash code（首尾增删，线性时间），存储对应的value为该子字符串的左起始点，另用一个数组存储各起始点的子字符串的出现次数（times），初始化为0。如果一个子字符串hash code对应的value非空，那么对应的value在times数组里的值+1. 如此即可找到各个长度为len的各个子字符串的出现次数。先返回最大值。
  * 二分算法。如果存在L长度的m次串，那么一定存在L-1长度的。因此，随着子串长度的减小，其最大重复次数至少是非降的。我们首先需要找到一个串长度，它使最大重复次数大于等于m且最小，因而该串长度必然是最大重复次数大于等于m中最长的。hi为n，lo为1，二分查找即可得到。
  * 得到最长串长度后，仍然计算该长度的各字符串的出现次数，找到所有出现次数大于等于m的最右侧的一个串的最左侧起始点。然后再对该串找出最右侧起始点。
  * 但是最后测试结果很差，我想应该多用个hash函数――可惜没时间了（都被续了
3. 时间和空间复杂度的估算。

   计算hash：$O(n)$，总共$n$层，故为$O(n\log n)$。空间复杂度为$O(n)$。

4. （可选）介绍理论分析与实测效果的吻合程度，不吻合时进一步解释原因。

5. （可选）所用方法的特别、新颖或创新之处。