1. 所使用数据结构与算法的构思、原理和实现要点。
	完成过程中主要使用了AVL树，因为涉及到多次插入和删除。
我实现的方法主要参考：http://blog.csdn.net/liyizhixl/article/details/65641346。
但是他的代码使用的是数组，因此我只借用了他的思路。也就是用贪心算法外加平衡树：先把所有的石桥和材料按照美化度由大到小做一次快排（美化度相同时按照钱由大到小排）。然后对于所有的石桥：找到所有能修它的材料，然后把材料插到树里面（树里面只存材料的钱，假如材料已经被插入，那么材料对应节点的数字+1）。再然后在树里面取出一个可以修它的而且钱最少的材料，取出材料，材料数-1。如果减到0，删掉它。

2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
	我主要的问题在于对于某个石桥找到能修它的材料。因为题目中已经说了对于第 i 种修理材料能成功修理第 j 个石桥的条件是：当且仅当 hi ≥ pj，di ≥ vj。但是我一直出错，50%测试只有一个正确，让我debug很久。后来群里的北极光同学说有的测例比较特殊，会出现石桥全在材料右下角的情况。我想我正确的那个应该恰好对应这种情况，进而推断出我的条件太强了，于是我分别试着去掉一个条件。发现只要美化度满足要求就行了。真是有点奇怪。
	还有一个问题在于，如何从一颗树里面找到大于等于某个目标值的最小值呢？其实也很简单，用一个值（比如hot）专门记录在当前遍历过的节点中大于等于目标值的最小值。初始化为最大整数，然后到达某个节点就用该节点的数据来更新hot（当然大于等于目标值且小于hot的时候更新）。

3. 时间和空间复杂度的估算。
	时间复杂度：快速排序为O(nlogn)，插入和取出均为O(logn)，总体为O(logn)。
	空间复杂度：存石桥和材料分别为O(n)，树也是O(n)，总体为O(n)。

4. （可选）介绍理论分析与实测效果的吻合程度，不吻合时进一步解释原因。
5. （可选）所用方法的特别、新颖或创新之处。