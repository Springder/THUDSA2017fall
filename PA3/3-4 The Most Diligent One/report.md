1. 所使用数据结构与算法的构思、原理和实现要点。
  主要使用了字典树(trie tree)。字典树子孩子是节点向量。插入一个字符串时需要看某一层是否有某字符，没有需要插入。同时，每个节点需要记录是否是一个词语结束之处(workMarker)，也需要记录出现次数(num)。
2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
  问题在于若用string类型则对于'\0'的处理比较麻烦。于是我干脆采用getchar()一个一个地将字符读入char*里面，并且读入的时候会记录字符串的长度。然后将读入的字符串插入即可。插入的时候也会记录当前出现次数最多的词语的次数，如果插入时发现超过了，那么会更新次数，也会更新用该词语更新用于记录的char *。
3. 时间和空间复杂度的估算。
  时间复杂度：n次插入。每层一般需要遍历到向量的中间，约13（总共26个字母）. 总共不超过8层，因此总体来说可以在O(n)时间内完成插入。
  空间复杂度：每层最多26个字符，总共8层。每层还有marker、num之类。一般来说，不重复的字符串与n应该是一个量级（假如人名大量重复就太可怕了！），因此空间复杂度为O(n)。

4. （可选）介绍理论分析与实测效果的吻合程度，不吻合时进一步解释原因。
5. （可选）所用方法的特别、新颖或创新之处。