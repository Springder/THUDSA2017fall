1. 所使用数据结构与算法的构思、原理和实现要点。
	由领接表实现的图。要点在于边用list
2. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
	参考http://www.cnblogs.com/shanyou/archive/2006/11/16/562861.html
	完成拓扑排序后，从初始状态中入度为0的点出发，不断往拓扑排序下面的数进行距离更新。
	具体实现为一开始对于所有的顶点，开一个数组记录它们到某零入度点的距离，初始化为100,000,000（因为总共最多100,000个点,而差价最多1,000）。零入度点本身记为0. 然后在拓扑排序结果中找到它，不断往下更新距离。即循环它所有的连接的顶点，如果相邻顶点的距离大于两点的weight+该顶点的距离，更新相邻顶点的距离。如此重复。因为零入度点所能到达的最长路径肯定在拓扑排序的结果中位于该零入度点之后，所以本算法必然能找到最长路径，只要每次把计算好的距离的最大值取出来即可。
3. 时间和空间复杂度的估算。
	时间复杂度：总共n个点，m条边，平均每个点2*m/n条边（一条边对应两个顶点）。插入顶点需要O(n)的时间，插入边需要看某个点是否已经有了该条边，因此平均需要2m/n的时间，总共需要O(2m^2/n)的时间。拓扑排序时，首先遍历顶点找出入度为0的点，需要O(n)。从最终结果看，所有顶点的入度均减到0，需要O(m)的时间。因此拓扑排序的复杂度为O(m+n)。
	空间复杂度：O(m)，主要是存m条边。

4. （可选）介绍理论分析与实测效果的吻合程度，不吻合时进一步解释原因。
5. （可选）所用方法的特别、新颖或创新之处。